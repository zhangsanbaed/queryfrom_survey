"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringInMemoryStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve 
  deployment information for ConfidentialHealthSurvey.sol:
  
  - <root>/packages/frontend/abi/abi/ConfidentialHealthSurveyABI.ts
  - <root>/packages/frontend/abi/abi/ConfidentialHealthSurveyAddresses.ts
*/
import { ConfidentialHealthSurveyAddresses } from "@/abi/ConfidentialHealthSurveyAddresses";
import { ConfidentialHealthSurveyABI } from "@/abi/ConfidentialHealthSurveyABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type SurveyInfo = {
  id: number;
  creator: string;
  title: string;
  description: string;
  metadataPointer: string;
  questionSchemaPointer: string;
  submitDeadline: number;
  allowIndividualReveal: boolean;
  isActive: boolean;
  totalSubmissions: number;
};

export type SubmissionInfo = {
  surveyId: number;
  entryId: number;
  respondent: string;
  commitment: string;
  ciphertextStoragePointer: string;
  timestamp: number;
  isRevealed: boolean;
};

type ConfidentialHealthSurveyInfoType = {
  abi: typeof ConfidentialHealthSurveyABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves ConfidentialHealthSurvey contract metadata for the given EVM `chainId`.
 */
function getConfidentialHealthSurveyByChainId(
  chainId: number | undefined
): ConfidentialHealthSurveyInfoType {
  if (!chainId) {
    return { abi: ConfidentialHealthSurveyABI.abi };
  }

  const entry =
    ConfidentialHealthSurveyAddresses[chainId.toString() as keyof typeof ConfidentialHealthSurveyAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: ConfidentialHealthSurveyABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: ConfidentialHealthSurveyABI.abi,
  };
}

export const useConfidentialHealthSurvey = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringInMemoryStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [surveys, setSurveys] = useState<SurveyInfo[]>([]);
  const [submissions, setSubmissions] = useState<SubmissionInfo[]>([]);
  const [aggregateHandles, setAggregateHandles] = useState<Record<string, string>>({});
  const [clearAggregates, setClearAggregates] = useState<Record<string, ClearValueType>>({});
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const contractRef = useRef<ConfidentialHealthSurveyInfoType | undefined>(undefined);
  const isLoadingRef = useRef<boolean>(isLoading);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Info
  //////////////////////////////////////////////////////////////////////////////

  const contract = useMemo(() => {
    const c = getConfidentialHealthSurveyByChainId(chainId);

    contractRef.current = c;

    if (!c.address) {
      setMessage(`ConfidentialHealthSurvey deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Status
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!contract) {
      return undefined;
    }
    return (Boolean(contract.address) && contract.address !== ethers.ZeroAddress);
  }, [contract]);

  const canInteract = useMemo(() => {
    return contract.address && ethersReadonlyProvider && !isLoading;
  }, [contract.address, ethersReadonlyProvider, isLoading]);

  //////////////////////////////////////////////////////////////////////////////
  // Survey Management
  //////////////////////////////////////////////////////////////////////////////

  const createSurvey = useCallback(async (
    title: string,
    description: string,
    metadataPointer: string,
    questionSchemaPointer: string,
    submitDeadline: number,
    allowIndividualReveal: boolean,
    initialResearchers: string[] = []
  ) => {
    if (!contract.address || !ethersSigner || isSubmittingRef.current) {
      return;
    }

    isSubmittingRef.current = true;
    setIsSubmitting(true);
    setMessage("Creating survey...");

    try {
      const contractInstance = new ethers.Contract(
        contract.address,
        contract.abi,
        ethersSigner
      );

      const tx = await contractInstance.createSurvey(
        title,
        description,
        metadataPointer,
        questionSchemaPointer,
        submitDeadline,
        allowIndividualReveal,
        initialResearchers
      );

      setMessage(`Waiting for tx: ${tx.hash}...`);
      const receipt = await tx.wait();
      setMessage(`Survey created! Status: ${receipt?.status}`);

      // Refresh surveys list
      await loadSurveys();
    } catch (error) {
      setMessage(`Failed to create survey: ${error}`);
    } finally {
      isSubmittingRef.current = false;
      setIsSubmitting(false);
    }
  }, [contract.address, contract.abi, ethersSigner]);

  const loadSurveys = useCallback(async () => {
    if (!contract.address || !ethersReadonlyProvider || isLoadingRef.current) {
      return;
    }

    isLoadingRef.current = true;
    setIsLoading(true);

    try {
      const contractInstance = new ethers.Contract(
        contract.address,
        contract.abi,
        ethersReadonlyProvider
      );

      // Load surveys dynamically by checking nextSurveyId
      const nextSurveyId = await contractInstance.nextSurveyId();
      const surveyPromises = [];
      for (let i = 1; i < Number(nextSurveyId); i++) {
        surveyPromises.push(
          contractInstance.getSurveyInfo(i).catch(() => null)
        );
      }

      const results = await Promise.all(surveyPromises);
      const validSurveys = results
        .filter((result) => result !== null)
        .map((result) => ({
          id: Number(result.id),
          creator: result.creator,
          title: result.title,
          description: result.description,
          metadataPointer: result.metadataPointer,
          questionSchemaPointer: result.questionSchemaPointer,
          submitDeadline: Number(result.submitDeadline),
          allowIndividualReveal: result.allowIndividualReveal,
          isActive: result.isActive,
          totalSubmissions: Number(result.totalSubmissions),
        }));

      setSurveys(validSurveys);
    } catch (error) {
      setMessage(`Failed to load surveys: ${error}`);
    } finally {
      isLoadingRef.current = false;
      setIsLoading(false);
    }
  }, [contract.address, contract.abi, ethersReadonlyProvider]);

  //////////////////////////////////////////////////////////////////////////////
  // Survey Submission
  //////////////////////////////////////////////////////////////////////////////

  const submitSurveyEntry = useCallback(async (
    surveyId: number,
    answers: number[],
    commitment: string,
    ciphertextStoragePointer: string
  ) => {
    if (!contract.address || !ethersSigner || !instance || isSubmittingRef.current) {
      return;
    }

    isSubmittingRef.current = true;
    setIsSubmitting(true);
    setMessage("Submitting survey entry...");

    try {
      const contractInstance = new ethers.Contract(
        contract.address,
        contract.abi,
        ethersSigner
      );

      // Create encrypted inputs
      const input = instance.createEncryptedInput(
        contract.address,
        ethersSigner.address
      );

      // Add all answers
      answers.forEach(answer => {
        input.add32(answer);
      });

      // Encrypt
      const enc = await input.encrypt();

      // Submit to contract
      // Create proofs array with same length as handles
      const proofs = new Array(enc.handles.length).fill(enc.inputProof);
      
      const tx = await contractInstance.submitEntry(
        surveyId,
        enc.handles,
        proofs,
        commitment,
        ciphertextStoragePointer
      );

      setMessage(`Waiting for tx: ${tx.hash}...`);
      const receipt = await tx.wait();
      setMessage(`Survey submitted! Status: ${receipt?.status}`);

      // Refresh data
      await loadSurveys();
    } catch (error) {
      setMessage(`Failed to submit survey: ${error}`);
    } finally {
      isSubmittingRef.current = false;
      setIsSubmitting(false);
    }
  }, [contract.address, contract.abi, ethersSigner, instance, loadSurveys]);

  //////////////////////////////////////////////////////////////////////////////
  // Aggregate Decryption
  //////////////////////////////////////////////////////////////////////////////

  const canDecryptAggregate = useMemo(() => {
    return (
      contract.address &&
      instance &&
      ethersSigner &&
      !isLoading &&
      !isDecrypting
    );
  }, [contract.address, instance, ethersSigner, isLoading, isDecrypting]);

  const decryptAggregate = useCallback(async (
    surveyId: number,
    questionId: number
  ) => {
    console.log('decryptAggregate called:', { 
      surveyId, 
      questionId, 
      contractAddress: contract.address, 
      hasInstance: !!instance, 
      hasEthersSigner: !!ethersSigner, 
      isDecrypting: isDecryptingRef.current 
    });
    
    if (!contract.address || !instance || !ethersSigner || isDecryptingRef.current) {
      console.log('decryptAggregate early return:', { 
        hasContract: !!contract.address, 
        hasInstance: !!instance, 
        hasSigner: !!ethersSigner, 
        isDecrypting: isDecryptingRef.current 
      });
      return;
    }

    const handleKey = `${surveyId}-${questionId}`;
    const currentHandle = aggregateHandles[handleKey];

    if (!currentHandle || currentHandle === ethers.ZeroHash) {
      setMessage("No aggregate data to decrypt");
      return;
    }

    if (clearAggregates[handleKey]?.handle === currentHandle) {
      setMessage("Already decrypted");
      return;
    }

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Decrypting aggregate...");

    try {
      const sig: FhevmDecryptionSignature | null =
        await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contract.address as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

      if (!sig) {
        setMessage("Unable to build FHEVM decryption signature");
        return;
      }

      const res = await instance.userDecrypt(
        [{ handle: currentHandle, contractAddress: contract.address }],
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      setClearAggregates(prev => ({
        ...prev,
        [handleKey]: { handle: currentHandle, clear: res[currentHandle] }
      }));

      setMessage("Aggregate decrypted successfully!");
    } catch (error) {
      setMessage(`Failed to decrypt aggregate: ${error}`);
    } finally {
      isDecryptingRef.current = false;
      setIsDecrypting(false);
    }
  }, [
    contract.address,
    instance,
    ethersSigner,
    aggregateHandles,
    clearAggregates,
    fhevmDecryptionSignatureStorage
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Load Aggregate Handles
  //////////////////////////////////////////////////////////////////////////////

  const loadAggregateHandles = useCallback(async (surveyId: number, questionId: number) => {
    if (!contract.address || !ethersReadonlyProvider) {
      return;
    }

    try {
      const contractInstance = new ethers.Contract(
        contract.address,
        contract.abi,
        ethersReadonlyProvider
      );

      const [sumHandle, countHandle] = await Promise.all([
        contractInstance.getAggregateCiphertext(surveyId, questionId),
        contractInstance.getAggregateCount(surveyId, questionId)
      ]);

      const handleKey = `${surveyId}-${questionId}`;
      setAggregateHandles(prev => ({
        ...prev,
        [handleKey]: sumHandle
      }));

      setMessage(`Loaded aggregate handles for survey ${surveyId}, question ${questionId}`);
    } catch (error) {
      setMessage(`Failed to load aggregate handles: ${error}`);
    }
  }, [contract.address, contract.abi, ethersReadonlyProvider]);

  // Clear aggregates function
  const clearAllAggregates = useCallback(() => {
    setAggregateHandles({});
    setClearAggregates({});
    setMessage("Aggregates cleared");
  }, []);

  // Auto load surveys on mount
  useEffect(() => {
    loadSurveys();
  }, [loadSurveys]);

  return {
    contractAddress: contract.address,
    surveys,
    submissions,
    aggregateHandles,
    clearAggregates,
    clearAllAggregates,
    canInteract,
    canDecryptAggregate,
    canSubmit: contract.address && ethersSigner && instance && !isSubmitting,
    createSurvey,
    submitSurveyEntry,
    decryptAggregate,
    loadAggregateHandles,
    loadSurveys,
    message,
    isLoading,
    isDecrypting,
    isSubmitting,
    isDeployed
  };
};
